---
title: "R Notebook"
output: html_notebook
---

```{r, warning=FALSE, message=FALSE}
library(stringr)
library(tidyverse)
library(magrittr)
library(lubridate)
library(reshape2)
library(readr)
library(purrr)

source('functions.R')
```

```{r}
### Local file paths

# ProPublica analysis
f_propub = "../compas-analysis/"

# Data we have pulled
f_our_data = "../our_data/"
```

```{r}
### Load ProPublica tables

## Connect to the database
db <- src_sqlite(paste0(f_propub,"compas.db"), create = TRUE)

## Convert tables to dataframes
casearrest_df <- tbl(db,"casearrest") %>%
  as_data_frame()

charge_df <- tbl(db,"charge") %>%
  as_data_frame() %>%
  filter(charge_degree != "(0)") %>% # These are very minor offenses (e.g. traffic tickets). We will never use them.
  mutate(offense_date = as_date(ymd_hms(offense_date)))

compas_df <- tbl(db,"compas") %>%
  as_data_frame() %>%
  mutate(screening_date = as_date(ymd_hms(screening_date)))

jailhistory_df <- tbl(db,"jailhistory") %>%
  as_data_frame() %>%
  mutate(dob = ymd_hms(dob),
         in_custody = as_date(ymd_hms(in_custody)),
         out_custody = as_date(ymd_hms(out_custody)))

prisonhistory_df <- tbl(db,"prisonhistory") %>%
  as_data_frame()

people_df<-tbl(db,"people") %>%
  as_data_frame() %>%
  mutate(dob = as_date(ymd_hms(dob))) %>%
  rename(person_id = id)

## Cleanup
rm(db)
gc()
```

```{r}
### Load our data
#fail_to_appear <- read_csv(paste0(f_our_data,"fail_to_appear.csv"))
#convictions <- read_csv(paste0(f_our_data,"convicted_from_disps.csv"))
```

COMPAS scores should be unique by person_id and screening_date. If there are COMPAS scores with the same person_id and screening_date, only one can be used. I will take the one with the larger `compas_case_id`.

```{r}
# Check how many duplicates there are
compas_df %>%
  group_by(person_id, screening_date) %>%
  summarize(duplicate = n() > 3) %>%
  group_by(duplicate) %>%
  summarize(count = n())

# Remove duplicates
compas_df2 = compas_df %>%
  group_by(person_id, screening_date) %>%
  arrange(desc(compas_case_id)) %>% 
  dplyr::slice(1:3) # Should be three scores for each compas_case_id
```


```{r}
# Convert compas scores to wide format (one row per person_id/screening_date combination)
compas_df_wide = compas_df2 %>%
  select(person_id, screening_date, type_of_assessment, raw_score, decile_score) %>%
  gather("key","value",raw_score,decile_score) %>%
  unite(temp, type_of_assessment, key) %>%
  spread(temp, value) %>%
  ungroup()

# Compute the date of the first offense
key_first_offense = compas_df_wide %>%
  left_join(charge_df, by="person_id") %>% # Duplicate charges for each screening_date
  group_by(person_id, screening_date) %>%
  summarize(first_offense_date = min(offense_date))

# Compute the date of the current offense
key_current_offense = compas_df_wide %>%
  left_join(charge_df, by="person_id") %>% # Duplicate charges for each screening_date
  mutate(days_offense_screening = floor(as.numeric(as.period(interval(offense_date,screening_date)), "days"))) %>%
  filter(days_offense_screening >= 0 & days_offense_screening <= 30) %>%
  group_by(person_id, screening_date) %>%
  summarize(current_offense_date = max(offense_date))

# Record important dates
key_events = compas_df_wide %>%
  select(person_id, screening_date) %>%
  left_join(key_first_offense, by = c("person_id","screening_date")) %>%
  left_join(key_current_offense, by = c("person_id","screening_date"))
```


```{r}
### Add columns to ProPublica tables. Each entry should depend only on other entries in the same row.

charge_df = charge_df %>%
  mutate(
    is_violent=if_else(substr(statute,1,3) %in% c("741","777","782","784","794",
                                                  "806","812","825","827"),1,0),
    is_felony = if_else(substr(charge_degree,2,2)=="F",1,0),
    is_misdem= if_else(substr(charge_degree,2,2)=="M",1,0),
    is_property=if_else(substr(statute,1,3) %in% c("806","810","812"),1,0),
    is_murder=if_else(substr(statute,1,3) %in% c("782"),1,0),
    is_assault=if_else(substr(statute,1,3) %in% c("784"),1,0),
    #not including murder, sex, domestic violence, but I
    #think I need to look at this more closely
    is_family_violence=if_else(substr(statute,1,6)=="741.28",1,0),
    is_sex_offense=if_else(substr(statute,1,3)=="794"|
                             substr(statute,1,7)=="784.046",1,0),
    is_weapons=if_else(substr(statute,1,3)=="790",1,0),
    is_felprop_violarrest=if_else(is_violent==1&is_felony==1&is_property==1,1,0),
    is_felassault_arrest=if_else(is_felony==1&is_assault==1,1,0),
    is_misdemassault_arrest=if_else(is_misdem==1&is_assault==1,1,0)
  )
```

Now we group each ProPublica table into a nested dataframe. Each row represents a person_id/screening_date combination. The dataframe nested in each row includes all information in the corresponding ProPublica table that is relevant to the compas score of that person_id/screening_date combination. By using a left_join on person_id we duplicate the information in the ProPublica table for each screening_date (since there can be multiple matches). The prefix `dyn` means the information can change over time (e.g., prior offenses), while the prefix `stat` means the information should not change (e.g., date of birth).

```{r}
dyn_charge = key_events %>%
  left_join(charge_df, by="person_id") %>% # Duplicates features for different screening_dates
  filter(offense_date < current_offense_date) %>% # Only charges before the current offense should matter
  select(-first_offense_date, -current_offense_date) %>% # Don't need these here now
  group_by(person_id, screening_date) %>%
  nest(.key="charge")

dyn_jail = key_events %>%
  left_join(jailhistory_df, by="person_id") %>% 
  filter(in_custody < current_offense_date) %>% 
  select(-first_offense_date, -current_offense_date) %>% 
  group_by(person_id, screening_date) %>%
  nest(.key="jail") 

stat_people = key_events %>%
  left_join(people_df, by="person_id") %>% 
  select(-first_offense_date, -current_offense_date) %>% 
  group_by(person_id, screening_date) %>%
  nest(.key="people") 
```

```{r}
### Join all information together. Each row is a unique person_id/screening_date.
features_input = key_events %>%
  left_join(dyn_charge, by=c("person_id","screening_date")) %>%
  left_join(dyn_jail, by=c("person_id","screening_date")) %>%
  inner_join(stat_people, by=c("person_id","screening_date")) # Should be 1-1 mapping between dataframes
```

If the `first_offense_date` is equal to the `current_offense_date`, then they should have no charge information (since only charges prior to their current charge are relevant). If `first_offense_date` is `NA`, then they have no charge information at all. If `first_offense_date` is not `NA` but `current_offense_date` is `NA`, then they have prior offenses but have no offenses that qualified as the current offense. When they have no prior offenses at all it is not clear if this is because they actually have no priors or if they do and we don't have it. 

```{r}
### Compute features (e.g., number of priors) for each person_id/screening_date combination.
features = pmap_dfr(features_input, .f=compute_features)
```

```{r}
### Join with COMPAS scores=
features = key_events %>%
  inner_join(features, by=c("person_id","screening_date")) %>%
  inner_join(compas_df_wide, by=c("person_id","screening_date"))
```

```{r}
write_csv(features, "features_vB.csv")
```



